---
title: "系统概论"
layout:  page
collection: "[系统纲]"
date: 2017-09-06 21:00:00
---

**文档状态：**<a style="color:red;background-color:gray">编辑....</a>

---
- **今日音乐**
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=286999&auto=0&height=66"></iframe>

---
> 学习操作系统,如果仅仅将眼光局限于计算机,成就仅仅止于计算机,更重要的是,设计系统的策略.

---



[TOC]


---
###what is
---

- 每当谈到操作系统时,我更倾向于把它称为系统,很多人只是在界限上给操作系统划分为一个系统软件类别,而在我眼里,并不是那么粗糙的去定义它,它的确是一个软件,但是在逻辑上讲,更像是一组提高用户交互性,管理计算机资源与实现流程控制的一组功能之上的策略的集合。任何系统都是策略的集合,无论是计算机操作系统,还是计算机网络系统。

---
###发展史
---

/*这个有很多要讲*/

- 单道批处理()
- 多道批处理
- 分时
- 并发

计算机网络中对于cs模型具有重复型或并发型，看起来具有共同之处

---
###Design OS
---

0. 好了现在我要设计一个操作系统它的结构应该是什么

```python
----------
  ROOT
   |___boot[BOOTLOADER区域]
   |     |___bootasm.S[主要完成实模式-->保护模式//]
   |     |___bootmain.c[加载操作系统内核,处理机权限移交]
   |     |___asm.h[一些宏定义]
   |___kern[内核代码区]
   |     |___init[初始化]
   |     |      |___init.c[操作系统初始化]
   |     |
   |     |___MemoryManager[内存管理]
   |     |      |___*+*[细节待补充]
   |     |
   |     |___Driver[外设驱动管理]
   |     |      |___intr.[ch][操纵eflags来控制屏蔽和使能中断的函数]
   |     |      |___picirq.[ch][CON中断控制器的初始化和使能操作]
   |     |      |___clock.[ch][realize时钟控制器的初始化操作]
   |     |      |___console.[ch][对串口和键盘的中断方式的处理操作]
   |     |
   |     |___Trap[中断处理部分]
   |     |      |___vectors.S[含N个中断服务例程的入口地址和第一步初处理实现]
   |     |      |        \___是动态生成的[/tool/vactor.c]
   |     |      |___trapentry.S[完成第二步初步处理,并有恢复中断上下文的处理]
   |     |      |___trap.[ch][紧接第二步初处理后,继续完成具体各种中断处理操作]
   |     |      
   |     |___Debug[暂不介绍,主要是调试工程]
   |     |
   |     |___libs
   |           |___readline.c
   |           |___stdio.c
   |     
   |___libs[公共库部分]
   |     |___defs.h*[包含一些无符号整型的缩写定义]
   |     |___x86.h[一些用GNU	C嵌入式汇编实现的C函数]
   |     
   |___tools[工程开发的自定义工具]
   |     |___vector.c[生成vectors.S,此文件包含了中断向量处理的统一实现]
   |     |___sign.c[C语言小程序,辅助工具,用于生成一个符合规范的硬盘主引导扇区]
   |     |___function.mk[指导make完成整个软件项目的编译,清除等工作]
   |    
   |___makefile[工程需求]
```

1. 我看见很多人以对寄存器位数或者地址线根数的来判断操作系统的位数，诚然更多的地址线意味着操作系统的物理内存空间变得更加大，但是地址线的增加并非操作系统应用的策略，他是被动的增加的，认真的说如果内存没有增加单纯的增加地址线位数没有任何意义，但是又有人问了为什么使用逻辑地址扩大“寻址”范围，那么对了，这是一个策略，要想在8086的2^20[1M]加载大型程序简直是幻想，所以采用分段机制，当然这就是后话了，我们谈的是寄存器位数与地址线根数对计算机的影响，很明显寄存器的位数决定操作系统的位数，寄存器位数的增加可以明显降低总线的读写，增加程序的执行速度，而单纯的地址线增加又有什么用呢?有人说8086命名16位寄存器为什么要创造20位地址线呢？为什么不增加内存以增加更多地址线让8086拥有更多的物理地址，当然理论上是可以的，但是受当时工业条件的制约，内存1M就很大了，研发人员一计算发现需要20位地址线，但是寄存器只有16位，如何向20位地址总线传递16位信息，于是增加了地址修改逻辑，将地址转化。


2. 关于分段策略的执行，当然是为了更好的内存管理与使用，这都是被逼的！段机制在一定程度上保护了内核的安全性，可以想象以前程序访问地址都是确确实实的真实地址，如果知道内核进程的位置，进行数据篡改，计算机的安全性完全得不到保证，于是从<b style='color:green'>程序--->物理地址</b>转化为<b style='color:green'>程序-->段表--->物理地址</b>,段表是认为添加的，所以就相当于一个代理，既然出现了代理，就出现了可以控制的地址访问，于是人们将计算机的这种运行模式称为<b style='color:green'>保护模式</b>，在其之前的称为<b style='color:green'>实模式</b>.

3. 有人说计算机是为了保持兼容，保存了实模式，但是我并不认为是这种原因，仔细想想，建立段表这种工作要交给BIOS吗？虽然这项工作并不困难，关中断，开地址线，初始化段描述符，等等，但是要记住天下的系统并非你WINDOWS一家，我BIOS还是要面子的，每个操作系统建立的方式都不一样，你让我专门为你这样建立？没错，BOOTLOADER的工作我也没有做，因为作为底层抽象层，我的任务已经完成了。如果多做过于依赖某一平台那便是太不值得了！所以说建立段表自然需要一个地址，那么用一个专用的寄存器保存它的地址，毕竟经常用。

4. 精彩部分来了，我们要使用段表来通过逻辑地址定位真实物理地址，我们需要用到什么东西呢？[这里我们将段描述符表看成透明的，因为我们暂时不想研究它的细节]
第一：地址由段地址+偏移地址组成，一人一个寄存器表示
第二：注意，看起来大多数是通过只转换段地址然后与偏移地址重新组合得到真实的地址

---
###messy pool
---
#### temp
- 加电 cs:ip = 0xf000:fff0
- post自检[寻找显卡和执行BIOS]
- 加载bootloader 到 0x7c00+512字节 控制转移
- 加载内核
####与设备交互
#####来源
- 面向外设 中断+io处理
- 面向系统程序 系统调用和异常提供服务

---
###FAQ
---

- 区分用户态与内核态

- 中断处理与子程序调用的区别
    `反正中断处理一定会保护程序状态字寄存器，而子程序调用不会`
- 中断向量地址是
    `中断服务例程地址的地址`
- 通用库函数可以执行特权吗？

- 应用程序发生异常时操作系统可能做什么？

- 操作系统执行中断处理的流程包括
    `保护现场与恢复现场是编译器做的`
    `执行中断应该不是他做的吧`

- 下列程序工作在内核态的有
    `系统调用[]`
    `中断处理程序[]`
    `进程调度[]`
    `内存管理[]`
系统调用在用户态发生，内核态执行，外部中断随时发生，应用程序执行时可能发生缺页

- 中断处理例程主要做什么
    `执行开/关中断特权指令`

- <b style='color:red'>为什么80386CPU32位机器,通用寄存器都是32位了,但段寄存器还是16位</b>
    `在80386CPU中保护模式下段寄存器的性质已经变了,他只是一个选择子,用于在段描述符表中选择自己的段描述符,而段描述符的数量不超过2^13个,所以仅仅16位的段寄存器就够了,如果你问为什么不超过2^13个,这和分段的大小有关,此处留在以后解释`
###寄存器
- psw(程序状态字)
    `用于记录当前处理器状态和控制指令的执行顺序，并且保留与运行相关的各种信息`
    `主要作用:实现程序状态的恢复与保护`
    `中断经常用到，但子程序调用不会用到，因为子程序调用在程序内部执行`
