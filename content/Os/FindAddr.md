---
title: "寻址方式"
layout:  page
collection: "[策略目]"
date: 2017-09-22 09:00:00
---

**文档状态：**<a style="color:red;background-color:gray">编辑....</a>

---
- **今日音乐**
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=286999&auto=0&height=66"></iframe>

---
> 寻址的意义重大

---

<b style="color:red"></b>


[TOC]

#寻址方式
> 通常是指cpu指令中规定的寻找<操作数>所在地址的方式.


##8086
---
###分类方式
---
- 按照用什么载体去寻址划分[寄存器|内存|直接数]
- 按照寻操作数种类划分[寄存器|内存|直接数]
- 书上写过寻址方式扩大寻址空间这种事情,感觉说起来好别扭,寻址空间能有多大,不是地址线的数量决定的吗?难道不应该说增强了寻址的层次性.
- 上面的三点谈论存在<b style='color:red'>issue</b>,所以只能作为参考依据

---
###立即寻址
---
####EX
```c
EX:
  MOV CL, 05
  MOV AX, 3100H
```
由上可以看出,操作数直接在指令中,直接取出来了

####设计角度
- 好处
    `[1]. 因为操作数在指令中,访存次数为1[取指令的时候,也可以认为在取指完访存为0],速度很快`
    `[2]. 书写很方便,一目了然`
- 坏处
    `[1]. 硬编码,不利于工程使用`
    `[2]. 好像有字节限制[待修改...]`

- 主要应用
    `[1]. 寄存器赋初值`
    `[2]. 存储单元赋初值`
- 注意事项
    `暂无`

---
###寄存器寻址
---
####EX
```c
EX:
  MOV SS, AX
```
指定某些cpu寄存器存放操作数.
这些寄存器可能为:
1. 通用数据寄存器(8/16bit)
2. [地址指针/变址]寄存器
3. 段寄存器

####设计角度
- 好处
    `[1]. 速度快`
    `[2]. /*暂停*/`
- 坏处
    `[1]. 存储值大小问题`
    `[2]. 不能实现内存读取数据`

- 特点
    `[1]. cpu内部执行,不占用总线周期`
    `[2]. 不用访问内存,`
####疑问
- 段寄存器能用来寄存器寻址?


---
###直接寻址
---
####EX
```c
EX:
  MOV AX, [3100H]#最好写够16bit

等价于:
  MOV AX, DS:[3100H]
计算:
  (DS)*10H+3100H-->AX
```

####设计角度
- 好处
    `[1]. 不知道实现了内存寻址的功能算不算`
- 坏处
    `[1]. 寻址范围受限于[]内长度,因为(DS)*10H已经做到极限了`
    `[2]. 访问主存获取操作数,不利于指令速度的提高`
    `[3]. 当数据的地址改变的时候,因为[3100H]为硬编码,需要修改`

- 应用
    `[1]. 自我感觉是操作那些内存地址固定的地方比如0x7c00`

####说明
[8086特性,不要随意推广]

- 隐含寄存器为DS
- 允许段超越
    `[1]. CS`
    `[2]. SS`
    `[3]. ES`
    `EX:  MOV AX, ES:[3100H]`

<b style='color:red'>注意了</b>由于选定4个寄存器作为间接寻址的工具,所以隐含寄存器不是唯一的,如上所示,还能进行SS:BP寻址.


####疑问
- 暂时没有

---
###寄存器间接寻址
---
####EX
```c
EX:
  MOV AX, [DI]

等价于:
  MOV AX, DS:[DI]
计算:
  (DS)*10H+(DI)-->AX
```
####说明
[8086特性,不要随意推广]

- 寄存器选用范围
    `|SI-->DS|`
    `|DI-->DS|`
    `|BX-->DS|`
    `|-------|`
    `|BP-->SS|`
- 应该允许段超越吧

####设计角度

- 好处
    `[1]. 和传统的间接寻址不一样,使用寄存器暂存偏移地址,减少了访问内存的次数`
    `[2]. 修正了直接寻址坏处[3], 消除硬编码问题`
    `[3]. 增大了寻址空间(目前还不太清楚)`
- 坏处
    `[1]. 暂无`
---
###变址寻址
---
####EX
```c
EX:
  MOV AX, [SI+3100H]
  MOV AX, [SI+LABEL]
等价于:
  MOV AX, DS:[SI+3100H]
计算:
  (DS)*10H+(SI)+3100H-->AX
```

####说明
[8086特性,不要随意推广]

- [学长实践]SI和DI最好放在指定的位置,有的机器会出错
    `MOV BX, [SI+2100H]     |--->SI(SOURCE)`
    `MOV [DI+1000H],  BX    |--->DI[DESTINATION]`

- 书写格式
    `可以有很多种书写格式`
    `[1]. MOV AX, TABLE[SI]`
    `[2]. MOV AX, [SI+TABLE]`
    `[3]. MOV AX, [SI]+TABLE`

- 隐含寄存器 DS
- 允许段超越

####设计角度
- 好处
    `[1]. 应该可以作为模块化的基础吧,可以实现段内的层次性寻址`
- 坏处
    `[1]. 暂无`
- 应用
    `[1]. 是面向用户设计的`
    `[2]. 用来解决程序在主存中的定位和扩大寻址空间问题`
---
###基址寻址
---


####EX
```c
EX:
  MOV SI, DATA[BX]
  MOV BLOCK[BP], AX
等价于:
  MOV SI, DS:[SI+DATA]
计算:
  (DS)*10H+(SI)+DATA-->SI
```

####说明
[8086特性,不要随意推广]

- 基址寄存器只使用BX/BP
- 隐含寄存器 BX-->DS, BP--->SS
- 允许段超越
- 多种书写方式

####设计角度
- 好处
    `[1]. 暂时没看出和变址寻址有什么卵区别,反正大家都允许段超越,可能对更高层次的抽象设计有影响吧
- 应用
    `[1]. 是面向系统设计的`
    `[2]. 访问字符向量和数组成的批数据`
---
###基址+变址寻址
---

####EX
```c
EX:
  MOV AX, DATA[BX][SI]
等价于:
  MOV AX, DS:[BX+SI+DATA]
计算:
  (DS)*10H+(BX)+(SI)+DATA-->SI
```

####说明
[8086特性,不要随意推广]

`指令中规定一个基址寄存器和一个变址寄存器,两个不能同时出现`
- 只允许一个基址寄存器和一个变址寄存器
- 隐含寄存器取决使用的基址寄存器 BX-->DS, BP--->SS
- 允许段超越
- 多种书写方式[以后补加]

####设计角度
- 好处
    `[1]. MMP,只看出对高级语言的二维数组设计有好处`
- 坏处
    `[1]. 暂无`
- 应用
    `[1]. 二维数组的访问`
