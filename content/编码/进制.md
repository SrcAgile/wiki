---
title: "进制介绍"
layout: page
collection: "[进制目]"
date: 2017-09-06 11:00:00
---
**文档状态：**<a style="color:red;background-color:gray">编辑中....</a>

---
> 编码让少量的数据存储大量的信息.

---
- **今日音乐**
```
暂无评论
```

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=386830&auto=0&height=66"></iframe>

---
[TOC]

##计算机进制

在 二进制,三进制,十进制的筛选中,选择了二进制,但这并不意味着二进制在某种程度上优于三进制

###进制的转换
---

<b>整数二进制转换</b>

```c
void trans(int m){
  if(m==1){
    printf("1");
    return;
  }
  trans(m/2);
  m%2==0?printf("0"):printf("1");
}
```

<b>纯小数二进制转换</b>
设小数二进制为0.$a_1,a_2,a_3...a_n$
设小数十进制为0.$b_1,b_2,b_3...b_n$
转化十进制公式 $(2^{-1}\times(a_1+2^{-1}\times(a_2+2^{-1}\times(...))))$
所以
对于十进制纯小数来说
在公式层面每乘一次相当于拆一层外围括号,露出里面的部分
在二进制运算层面相当于左移一位,此时看一看小数点左边第一位就行,如果是1就写1,反之则反.

`如果,上述的介绍你没有理解,那么,我有专门提供的简单方法,但是这种方法是答案,原理并不是显而易见`

这种办法和我上面说的实质上是一样的,所以这个是我从网上找的例子,<a>版权问题请联系</a>

```
以 20.5 转换为例，
20转换后变为  10100
0.5  要转换二进制，需要乘2, 乘完之后 取整数部分，然后用乘的结果减去整数部分， 然后 接着乘2, 直至最后没有小数或者小数出现循环,  即乘完.
如果等于0, 就取前面不为0的部分.
0.5 * 2  = 1.0 （取1）
0 * 2 = 0   (0)
所以,  转换后 0.5 = 0.1,
所以 20.5 转换二进制后， 20.5 = 10100.1(二进制)
--------------------------------
再看一个浮点数 20.3
 20 = 10100 (二进制)
0.3  * 2= 0.6  (0)
0.6  * 2 = 1.2  (1)
0.2  *  2=  0.4 (0)
0.4  * 2 = 0.8  (0)
0.8  *2 = 1.6   (1)

计算到这里， 将再出现0.6,进入循环了，所以，结果
0.3  = 0.010011001...1001
所以20.3 = 10100.010011001...1001 (二进制).
```
###谈谈语言中的进制转换
---
####Java
`仅在次怀念怎么都学不好的zz们`
```java
public class Float_Double {

	public static void main(String[] args) {

		float f_v1 = 20;  
		float f_v2 = 20.3f;  
		float f_v3 = 20.5f;  

		double d_v1 = 20;  
		double d_v2 = 20.3;  
		double d_v3 = 20.5;

		System.out.println((f_v1 == d_v1)?"true":"false");
		System.out.println(f_v2 == d_v2?"true":"false");  
		System.out.println(f_v3 == d_v3?"true":"false");

	}
}
```
当我看了一秒说出true,false,true时,学弟由等待出糗的表情变成了吃鲸...
他癫狂的说在Java中
float 占四个字节

|符号位|指数位|尾数位|
|:-:|:-----:|:---:|
|1位|占8位   |占23位|

double 占8个字节

|符号位|指数位|尾数位|
|:-:|:-----:|:---:|
|1位|占11位   |占52位|

先把20.5转化为二进制数,对于float来说,指数的值加127存入指数位,尾数为看着补零放入
对于double来说,指数的值加1023存入指数位,尾数为看着补零放入
在转型比较时,指数恢复原型减去127和减去1023,8位的指数位前面补三个0后进行指数位比较
23位的尾数位在后面补29个0,再进行尾数比较
这样才能算出啊=_=|

<b>听到这里我突然震惊了,0.3循环左移出现死循环永远移不完,而0.5移一次就行,肯定会在20.3转型时出现循环截断,那时候再往后面补0肯定是不会匹配的,一看就是20.3肯定不行,20.5肯定行</b>
他还狡辩到你这是对数据的不尊重,不适用严谨的无误的逻辑去推理.
<b>大概是你还不了解什么是工程吧.</b>
