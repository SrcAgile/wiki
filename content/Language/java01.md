---
title: "创建[J]清理"
layout: page
collection: "[三代目]"
date: 2017-09-02 21:00:00
---
**文档状态：**<a style="color:red;background-color:gray">编辑中....</a>

---
> 完备的系统在演变中浑然天成,要想在系统中添加新的功能,必须能够忍受带来的递归增长的问题.

---
- **今日音乐**
```
暂无评论
```

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=386830&auto=0&height=66"></iframe>

---
[TOC]

###草稿

```
###混乱中
---
- 对象的存储
    - 存储方式(位置)
基本类型存储在栈
自己创建的对象存储在堆
堆的速度慢
栈的速度快

栈要求知道生命周期
堆不需要知道生命周期以便操作栈指针

老师说生命周期并不是一个软件一个对象死了,而是指他该做的已经做了,他已经对现有系统没用了.对于软件来说,他的功能已经不足以现在的系统,他的生命周期已经结束了,所以你要经常维护他,让他成长,他的生命才会存在，并且生命周期一直会延长着.
- 插入题外话,现在要搜索结构化开发与面向对象开发的比较

###知识点
---
- 基本类型使用频繁,如果放入堆区难免影响速度,故放入栈区
- 新概念：包装基本类型

###策略
- 性能换功能
    - 速度换精度(包装类型BigInteger和BigDecimal)
```

###构造器
---
为了安全性考虑,java引入了构造器,不可避免的制定了目标,并在解空间建模之后,就要进行迭代的概要设计与详细设计

####功能需求
- 能够防止与其他方法重名
- 编译器自动调用,既然不能硬编码
`解决方案:那就和类一个名字吧`
`并且不能有返回类型,因为返回了编译期也没办法处理,毕竟返回值的处理不好泛化`
- 提出新的需求,考虑到一个对象的初始化有很多方式,引入重载
`没办法再加一个功能吧,反正大家也都能用,又不是只让构造器用`
- 既然重载了,就把我上一章提到的方法签名拿出来吧
`参数列表就是方法签名`
    - 参数的顺序
    - 参数的多少
    - 参数的类型
- 为什么不用返回值来作为签名信息之一
`当只是使用方法的副作用的时候,而不是使用返回值会出现歧义。例如: f();请问是哪一个f(), int f() or void f()?`

###基本类型的重载
---
- 基本类型由于具有隐式的向上转型,致使很多人在调用时出错
`记住以下的介绍的就行,基本类型默认匹配参数一致的,对于直接数来说,整数为int为参数一致,只能向上转型,不能向下转型,毕竟信息可以丢失但不能缺失`

###this
---
类方法如何确定来的是哪个对象的调用,其实这句话我也不知道自己说的对不对,a.hello(),b.hello();hello怎么确定它前面是a还是b，解决这个问题我认为有两种,另外如果我想在构造器中调用构造器

- 将类方法代码复制一份到对象自己的私有空间,对象在私有空间对其进行调用,我认为这样不好
- 在调用的时候应该隐式的将对象的唯一标识传入方法即<b>this</b>
- <b style='color:red'>待解决:到底类的方法会不会复制一份到对象的独立区域</b>

对了,值得一提,this能够消除歧义

###清理
---
以前看了看垃圾回收器的作用,发现了一个问题,垃圾回收只能操作new出来的对象,万一脑子一抽不用new申请出一块特殊内存,垃圾回收器不知道怎么回收,那不出现内存泄漏了么？对此java引入了新的机制,finalize(),我把它称为”终结者“笑:-D
这里谈一谈垃圾回收器的强调
1. 垃圾回收器代表不了析构函数，之所以会用垃圾回收器是因为java贪图安全防止内存泄漏
一旦回收器准备释放某一部分空间时,他会先调用其finalize方法,然后在等到其应该执行回收动作的时候再进行真正的释放.所以说finalize并没有在真正的意义上将对象释放.
回收器开始工作时,垃圾不一定会被回收,因为垃圾回收器也占有一定的开销,冒昧的使用只会增大系统的浪费,所以在使用finalize方法时要注意,就像是声明要去做一样，但是不一定去做,如果去做了,一定会做完。

###再谈初始化
---
- 注意java和c++在指定初始化的不同
    `对于类成员的初始化,java可以直接指定赋值,而c++不行`
```java
    ##java
    line 1:public class Test{
    line 2:  public int a = 3;//正确
    line 3:  public char c = 'b';//正确
    line 4:  int f(int n){return 11*n;}//正确
    line 5:  int b = f(a);//正确
    }
    方法的引用可以是无序的
    所以line5和line4调换位置是不影响的
    但是参数的使用必须是有序的所以line2不能和line5换位
```

```java
   ##c++
   public class Test{
     public int a = 3;//错误
     public char c = 'b';//错误
   }
```

###构造器初始化
---
`涉及到初始化顺序`
<center>
![](https://raw.githubusercontent.com/srcmit/source/wiki/photo/initial.png)
</center>

###数组的初始化
---
- 创建方式[见后面文章 new {}]
- 基本类型的数组元素会自动被初始化为空值
- 自定义类型的数组元素会自动被初始化为空引用
- 产生一维数组的可打印版本,不用迭代了
    - Arrays.toString()
    `使用Arrays.toString(数组引用)`
- 使用初始化列表
```java
   new Integer{1,2,3,4,5};//作为参数
   int [] happy = {1,2,3,4,5};
```
- 可变参数列表
    `十分不赞同使用可变参数列表,毕竟有重载`
    `自己去了解老版的使用方式`
    `Object...args`
    `原理,编译器将参数组合为数组然后传递,所以要注意转型问题`
- 但是可变参数带来了重载的复杂性
有人说类型不是自动匹配吗,遇见相同的类型为最佳匹配,遇见较低的不匹配,遇见较高的向上转型,但是很多人忽略了一个问题,那就是没有参数的传递,到底该调用那个,在前面的重载中,我们以参数的可控长度重载方法,那时候我们知道,如果参数值长度是0的话,就要去找相应参数长度的重载方法,但是可变参数的引用搅乱了方法签名,以至于参数的长度与顺序均不起效,一旦参数的长度与顺序均不奇效,那么一旦出现参数的长度与顺序与以前不同的调用就出现了歧义,那么bug就出现了.
比如 `f()`,我特喵不知道该调用哪个重载的函数啊.
出现问题就要解决问题,为了防止参数长度与参数顺序的bug,首先要在书写重载方法时防范,对于固定类型的参数列表写一个就行了,除非有固定参数,因为0个参数不仅带来参数长度问题还带来参数类型问题,所以我们也是加一个固定类型的参数放在前面进行防范.

###枚举类型
---

```java
public emun circle{
  ONE,
  TWO.
  THREE,
  FOUR,
  FIVE,
  SIX,
  SEVEN,
}
```
- emun中定义的类方法
    - values(所有的emun值集合)
- emun中定义的对象方法
    - ordinal(每个值的序号 ONE->0,TWO->2...)

**可以使用在Switch**
